import{I as l,b as s,w,e as u,a4 as g,h as a,f as o}from"./index.293c77a4.js";import{n as f}from"./normalizeChainId-e4cc0175.browser.esm.042707b7.js";import{E as m,U as E}from"./thirdweb-dev-wallets.browser.esm.0c4493af.js";import"./errors-d961f852.browser.esm.61f33de0.js";import"./constants-1ba9df2b.browser.esm.1400d5f9.js";var n=new WeakMap,r=new WeakMap;class I extends l{constructor(e){super(),s(this,"id",w.paper),s(this,"name","Embedded Wallet"),s(this,"ready",!0),s(this,"user",null),u(this,n,{writable:!0,value:void 0}),u(this,r,{writable:!0,value:void 0}),s(this,"onAccountsChanged",async t=>{t.length===0?await this.onDisconnect():this.emit("change",{account:g(t[0])})}),s(this,"onChainChanged",t=>{const i=f(t),h=this.options.chains.findIndex(d=>d.chainId===i)===-1;this.emit("change",{chain:{id:i,unsupported:h}})}),s(this,"onDisconnect",async()=>{this.emit("disconnect")}),this.options=e}getEmbeddedWalletSDK(){return a(this,n)||o(this,n,new m({clientId:this.options.clientId,chain:"Ethereum",onAuthSuccess:this.options.onAuthSuccess})),a(this,n)}async connect(e){if(e){if(!e.authResult)throw new Error("Missing authData - call authenticate() first with your authentication strategy");if(!e.authResult.user)throw new Error("Missing authData.user - call authenticate() first with your authentication strategy");this.user=e.authResult.user}else{const t=await this.authenticate({strategy:"iframe"});if(!t.user)throw new Error("Error connecting User");this.user=t.user}return e!=null&&e.chainId&&this.switchChain(e.chainId),this.getAddress()}async disconnect(){const e=a(this,n);await(e==null?void 0:e.auth.logout()),o(this,r,void 0),o(this,n,void 0),this.user=null}async getAddress(){if(!this.user)throw new Error("Embedded Wallet is not connected");return this.user.walletAddress}async isConnected(){try{return!!await this.getAddress()}catch{return!1}}async getProvider(){const e=await this.getSigner();if(!e.provider)throw new Error("Provider not found");return e.provider}async getSigner(){if(a(this,r))return a(this,r);const e=await this.getUser(),t=await(e==null?void 0:e.wallet.getEthersJsSigner({rpcEndpoint:this.options.chain.rpc[0]||""}));if(!t)throw new Error("Signer not found");return o(this,r,t),t}async isAuthorized(){return!1}async switchChain(e){var i,h;const t=this.options.chains.find(d=>d.chainId===e);if(!t)throw new Error("Chain not configured");await((i=this.user)==null?void 0:i.wallet.setChain({chain:"Ethereum"})),o(this,r,await((h=this.user)==null?void 0:h.wallet.getEthersJsSigner({rpcEndpoint:t.rpc[0]||""}))),this.emit("change",{chain:{id:e,unsupported:!1}})}async setupListeners(){return Promise.resolve()}updateChains(e){this.options.chains=e}async getUser(){if(!this.user||!this.user.wallet||!this.user.wallet.getEthersJsSigner){const t=await this.getEmbeddedWalletSDK().getUser();switch(t.status){case E.LOGGED_IN_WALLET_INITIALIZED:{this.user=t;break}}}return this.user}async getEmail(){if(await this.getSigner(),!this.user)throw new Error("No user found, Embedded Wallet is not connected");return this.user.authDetails.email}async getRecoveryInformation(){if(await this.getSigner(),!this.user)throw new Error("No user found, Embedded Wallet is not connected");return this.user.authDetails}async sendVerificationEmail(e){let{email:t}=e;return this.getEmbeddedWalletSDK().auth.sendEmailLoginOtp({email:t})}async authenticate(e){const t=this.getEmbeddedWalletSDK(),i=e.strategy;switch(i){case"email_verification":return await t.auth.verifyEmailLoginOtp({email:e.email,otp:e.verificationCode,recoveryCode:e.recoveryCode});case"google":return t.auth.loginWithGoogle({closeOpenedWindow:e.closeOpenedWindow,openedWindow:e.openedWindow});case"jwt":return t.auth.loginWithCustomJwt({jwt:e.jwt,encryptionKey:e.encryptionKey});case"iframe_email_verification":return t.auth.loginWithEmailOtp({email:e.email});case"iframe":case void 0:return t.auth.loginWithModal();default:p(i)}}}function p(c){throw new Error("Invalid param: "+c)}export{I as EmbeddedWalletConnector};
