import{Y as ae,by as re,am as $,a7 as ne,bt as W,bz as f,bA as D,bk as x,bB as R,bC as _,_ as se,aG as ie,a5 as T,br as q,ah as b,a$ as G,bq as oe,bD as ce,aS as B,bl as p,bs as J,bE as le,b0 as j,bF as ue,aZ as Q,bG as de,bH as E,an as M,bI as me,bJ as O,bK as pe,bL as L,bM as ye}from"./index.293c77a4.js";import{S as Y,E as fe}from"./assertEnabled-e3719c36.browser.esm.4d41d034.js";import{N}from"./setErc20Allowance-87350278.browser.esm.ea5614f4.js";function Be(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function Ue(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function P(e,t){return e==="unlimited"?x:R(e,t)}async function Z(e){const a=Array.from({length:Math.ceil(e.length/25e3)},(s,i)=>e.slice(i*25e3,i*25e3+25e3)),n=[],r=await Promise.all(a.map(s=>L.parseAsync(s)));for(const s of r)n.push(...s);return n}const he=2;let U=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class h{constructor(t,a,n,r,s){this.storage=t,this.shardNybbles=r,this.baseUri=a,this.originalEntriesUri=n,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(t,a){try{const n=await a.downloadJSON(t);if(n.isShardedMerkleTree)return h.fromShardedMerkleTreeInfo(n,a)}catch{return}}static async fromShardedMerkleTreeInfo(t,a){return new h(a,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,a,n,r){switch(r){case U.V1:return Q(["address","uint256"],[t.address,P(t.maxClaimable,a)]);case U.V2:return Q(["address","uint256","uint256","address"],[t.address,P(t.maxClaimable,a),P(t.price||"unlimited",n),t.currencyAddress||b])}}static async fetchAndCacheDecimals(t,a,n){if(!n)return 18;let r=t[n];return r===void 0&&(r=(await de(a,n)).decimals,t[n]=r),r}static async buildAndUpload(t,a,n,r,s){let i=arguments.length>5&&arguments[5]!==void 0?arguments[5]:he;const o=await Z(t),c={};for(const C of o){const g=C.address.slice(2,2+i).toLowerCase();c[g]===void 0&&(c[g]=[]),c[g].push(C)}const u={},d=await Promise.all(Object.entries(c).map(async C=>{let[g,v]=C;return[g,new E.MerkleTree(await Promise.all(v.map(async A=>{const te=await h.fetchAndCacheDecimals(u,n,A.currencyAddress);return h.hashEntry(A,a,te,s)})),M,{sort:!0}).getHexRoot()]})),l=Object.fromEntries(d),y=new E.MerkleTree(Object.values(l),M,{sort:!0}),S=[];for(const[C,g]of Object.entries(c)){const v={proofs:y.getProof(l[C]).map(A=>"0x"+A.data.toString("hex")),entries:g};S.push({data:JSON.stringify(v),name:`${C}.json`})}const w=await r.uploadBatch(S),k=w[0].slice(0,w[0].lastIndexOf("/")),m=await r.upload(o),V={merkleRoot:y.getHexRoot(),baseUri:k,originalEntriesUri:m,shardNybbles:i,tokenDecimals:a,isShardedMerkleTree:!0},ee=await r.upload(V);return{shardedMerkleInfo:V,uri:ee}}async getProof(t,a,n){const r=t.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[r];const i={};if(s===void 0)try{const l=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[r]=await this.storage.downloadJSON(`${l}${r}.json`);const y=await Promise.all(s.entries.map(async S=>{const w=await h.fetchAndCacheDecimals(i,a,S.currencyAddress);return h.hashEntry(S,this.tokenDecimals,w,n)}));this.trees[r]=new E.MerkleTree(y,M,{sort:!0})}catch{return null}const o=s.entries.find(l=>l.address.toLowerCase()===t.toLowerCase());if(!o)return null;const c=await h.fetchAndCacheDecimals(i,a,o.currencyAddress),u=h.hashEntry(o,this.tokenDecimals,c,n),d=this.trees[r].getProof(u).map(l=>"0x"+l.data.toString("hex"));return me.parseAsync({...o,proof:d.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function Se(e,t,a,n,r,s){if(!a)return null;const i=a[t];if(i){const o=await r.downloadJSON(i);if(o.isShardedMerkleTree&&o.merkleRoot===t)return await(await h.fromShardedMerkleTreeInfo(o,r)).getProof(e,n,s);const c=await _.parseAsync(o);if(t===c.merkleRoot)return c.claims.find(u=>u.address.toLowerCase()===e.toLowerCase())||null}return null}function We(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function De(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function we(e,t,a,n,r){const s=e.getSigner(),i=e.getProvider(),o=(await se(()=>import("./index.293c77a4.js").then(S=>S.ev),["assets/index.293c77a4.js","assets/index.09a325bf.css"])).default,c=new ie(s||i,t,o,e.options,e.storage),u=await e.getSignerAddress(),d=e.address,l=await c.read("allowance",[u,d]),y=T.from(a).mul(T.from(n)).div(R("1",r));l.lt(y)&&await c.sendTransaction("approve",[d,l.add(y)])}async function qe(e,t,a,n,r,s,i,o,c){let u=P(a.maxClaimablePerWallet,r),d=[q([0],32)],l=a.price,y=a.currencyAddress;try{if(!a.merkleRootHash.toString().startsWith(b)){const m=await Se(e,a.merkleRootHash.toString(),await n(),s.getProvider(),i,c);if(m)d=m.proof,u=m.maxClaimable==="unlimited"?x:R(m.maxClaimable,r),l=m.price===void 0||m.price==="unlimited"?x:await G(s.getProvider(),m.price,m.currencyAddress||b),y=m.currencyAddress||b;else if(c===U.V1)throw new Error("No claim found for this address")}}catch(m){if((m==null?void 0:m.message)==="No claim found for this address")throw m;console.warn("failed to check claim condition merkle root hash, continuing anyways",m)}const S=await s.getCallOverrides()||{},w=l.toString()!==x.toString()?l:a.price,k=y!==b?y:a.currencyAddress;return w.gt(0)&&(oe(k)?S.value=T.from(w).mul(t).div(R("1",r)):o&&await we(s,k,w,t,r)),{overrides:S,proofs:d,maxClaimable:u,price:w,currencyAddress:k,priceInProof:l,currencyAddressInProof:y}}const be=(()=>p.object({name:p.string(),symbol:p.string(),decimals:p.number()}))(),Te=(()=>be.extend({value:f,displayValue:p.string()}))(),Ce=(()=>p.object({name:p.string().optional()}).catchall(p.unknown()))(),H=(()=>p.object({startTime:Y,currencyAddress:p.string().default(j),price:W.default(0),maxClaimableSupply:O,maxClaimablePerWallet:O,waitInSeconds:D.default(0),merkleRootHash:pe.default(q([0],32)),snapshot:p.optional(L).nullable(),metadata:Ce.optional()}))(),ge=(()=>p.array(H))(),K=(()=>H.extend({availableSupply:O,currentMintSupply:O,currencyMetadata:Te.default({value:T.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:f,waitInSeconds:f,startTime:f.transform(e=>new Date(e.toNumber()*1e3)),snapshot:L.optional().nullable()}))();async function Pe(e,t,a,n,r){const s=await Z(e),i=s.map(u=>u.address);if(new Set(i).size<i.length)throw new ye;const c=await h.buildAndUpload(s,t,a,n,r);return{merkleRoot:c.shardedMerkleInfo.merkleRoot,snapshotUri:c.uri}}function ke(e,t){const a=T.from(e),n=T.from(t);return a.eq(n)?0:a.gt(n)?1:-1}async function xe(e,t,a,n,r){const s=[];return{inputsWithSnapshots:await Promise.all(e.map(async o=>{if(o.snapshot&&o.snapshot.length>0){const c=await Pe(o.snapshot,t,a,n,r);s.push(c),o.merkleRootHash=c.merkleRoot}else o.merkleRootHash=q([0],32);return o})),snapshotInfos:s}}async function Ae(e,t,a,n){const r=e.currencyAddress===b?j:e.currencyAddress,s=P(e.maxClaimableSupply,t),i=P(e.maxClaimablePerWallet,t);let o;return e.metadata&&(typeof e.metadata=="string"?o=e.metadata:o=await n.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:i,pricePerToken:await G(a,e.price,r),currency:r,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:o}}async function je(e,t,a,n,r){const{inputsWithSnapshots:s,snapshotInfos:i}=await xe(e,t,a,n,r),o=await ge.parseAsync(s),c=(await Promise.all(o.map(u=>Ae(u,t,a,n)))).sort((u,d)=>ke(u.startTimestamp,d.startTimestamp));return{snapshotInfos:i,sortedConditions:c}}async function Ie(e,t,a){if(!t)return null;const n=t[e];if(n){const r=await a.downloadJSON(n);if(r.isShardedMerkleTree&&r.merkleRoot===e){const s=await h.fromUri(n,a);return(s==null?void 0:s.getAllEntries())||null}else{const s=await _.parseAsync(r);if(e===s.merkleRoot)return s.claims.map(i=>({address:i.address,maxClaimable:i.maxClaimable,price:i.price,currencyAddress:i.currencyAddress}))}}return null}function I(e,t){return e.toString()===x.toString()?"unlimited":B(e,t)}async function Le(e,t,a,n,r,s){var y;const i=await ce(a,e.currency,e.pricePerToken),o=I(e.maxClaimableSupply,t),c=I(e.maxClaimablePerWallet,t),u=I(T.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),d=I(e.supplyClaimed,t);let l;return e.metadata&&(l=await r.downloadJSON(e.metadata)),K.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:c,currentMintSupply:d,availableSupply:u,waitInSeconds:(y=e.waitTimeInSecondsBetweenClaims)==null?void 0:y.toString(),price:T.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:i,merkleRootHash:e.merkleRoot,snapshot:s?await Ie(e.merkleRoot,n,r):void 0,metadata:l})}async function He(e,t,a){if(e>=a.length)throw Error(`Index out of bounds - got index: ${e} with ${a.length} conditions`);const n=a[e].currencyMetadata.decimals,r=a[e].price,s=B(r,n),i=await H.parseAsync({...a[e],price:s,...t}),o=await K.parseAsync({...i,price:r});return a.map((c,u)=>{let d;u===e?d=o:d=c;const l=B(d.price,n);return{...d,price:l}})}let ze=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function Re(e){if(e===void 0){const t=ae.Buffer.alloc(16);return re({},t),$(ne(t.toString("hex")))}else return $(e)}const X=(()=>p.object({to:J.refine(e=>e.toLowerCase()!==b,{message:"Cannot create payload to mint to zero address"}),price:W.default(0),currencyAddress:le.default(j),mintStartTime:Y,mintEndTime:fe,uid:p.string().optional().transform(e=>Re(e)),primarySaleRecipient:J.default(b)}))(),Oe=(()=>X.extend({quantity:W}))(),Ve=(()=>Oe.extend({mintStartTime:f,mintEndTime:f}))(),z=(()=>X.extend({metadata:N,royaltyRecipient:p.string().default(b),royaltyBps:ue.default(0)}))(),F=(()=>z.extend({metadata:N.default(""),uri:p.string(),royaltyBps:f,mintStartTime:f,mintEndTime:f}))(),Ne=(()=>z.extend({metadata:N.default(""),quantity:D}))(),$e=(()=>Ne.extend({tokenId:D}))(),Je=(()=>F.extend({tokenId:f,quantity:f}))(),Qe=(()=>z.extend({metadata:N.default(""),quantity:f.default(1)}))(),_e=(()=>F.extend({quantity:f.default(1)}))(),Ge=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ye=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ze=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ke=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];var Xe=function e(t,a){if(t===a)return!0;if(t&&a&&typeof t=="object"&&typeof a=="object"){if(t.constructor!==a.constructor)return!1;var n,r,s;if(Array.isArray(t)){if(n=t.length,n!=a.length)return!1;for(r=n;r--!==0;)if(!e(t[r],a[r]))return!1;return!0}if(t.constructor===RegExp)return t.source===a.source&&t.flags===a.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===a.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===a.toString();if(s=Object.keys(t),n=s.length,n!==Object.keys(a).length)return!1;for(r=n;r--!==0;)if(!Object.prototype.hasOwnProperty.call(a,s[r]))return!1;for(r=n;r--!==0;){var i=s[r];if(!e(t[i],a[i]))return!1}return!0}return t!==t&&a!==a};export{X as B,ze as C,Ze as M,$e as S,we as a,Je as b,P as c,Xe as d,Be as e,Se as f,Ue as g,qe as h,U as i,Qe as j,_e as k,We as l,Ye as m,De as n,Ke as o,je as p,Oe as q,Ve as r,Ge as s,Le as t,He as u,Re as v};
